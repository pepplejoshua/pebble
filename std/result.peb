type Result[T, E] = union enum {
    Ok T;
    Err E;

    fn ok(value T) Result[T, E] {
        return Result.[T, E]{ Ok = value };
    }

    fn err(error E) Result[T, E] {
        return Result.[T, E]{ Err = error };
    }

    fn is_ok(self Result[T, E]) bool {
        switch self {
            case Ok: return true;
            case Err: return false;
        }
    }

    fn unwrap_or(self Result[T, E], def T) T {
        switch self {
            case Ok: return self.Ok;
            case Err: return def;
        }
    }

    fn map[U](self Result[T, E], f fn(T) U) Result[U, E] {
        switch self {
            case Ok: return Result.[U, E].ok(f(self.Ok));
            case Err: return Result.[U, E].err(self.Err);
        }
    }

    fn set_error(self *Result[T, E], error E) void {
        self.Err = error;
    }
};
