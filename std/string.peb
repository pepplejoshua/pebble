// An implementation of a growable string type
import "std:mem";

extern {
    fn memcpy(dst *void, src *void, n usize) *void;
    fn strlen(s str) usize;
}

type String = struct {
    data *char;
    len usize;
    capacity usize;
};

fn new() String {
    return String.{
        data = mem::new((sizeof char) * 4),
        capacity = 4,
        len = 0,
    };
}

fn delete(s *String) void {
    mem::delete(s.data);
    s.data = nil;
    s.len = 0;
    s.capacity = 0;
}

fn grow(s *String, new_cap usize) void {
    s.data = mem::realloc(s.data, (sizeof char) * new_cap);
    s.capacity = new_cap;
}

fn push_char(s *String, c char) void {
    if s.len + 1 >= s.capacity {
        grow(s, s.capacity * 2);
    }

    *(s.data + s.len) = c;
    s.len++;
    *(s.data + s.len) = '\0';
}

fn push_str(s *String, new_str str) void {
    var len = strlen(new_str);

    // Calculate needed capacity
    var needed = s.len + len + 1;
    if needed > s.capacity {
        var new_cap = s.capacity;
        while new_cap < needed {
            new_cap = new_cap * 2;
        }
        grow(s, new_cap);
    }

    // Copy
    var dst = s.data + s.len;
    var src = new_str as *void;
    memcpy(dst, src, len);

    s.len += len;
    *(s.data + s.len) = '\0';
}

fn as_str(s String) str {
    return s.data as str;
}

fn as_slice(s String) []char {
    return s.data[:s.len];
}
