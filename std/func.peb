import "std:mem";

fn map[T, Ret](items []T, operation fn(T) Ret) []Ret {
    var result = (mem::new(items.len * sizeof Ret) as *Ret)[:items.len];

    loop 0..items.len : i {
        result[i] = operation(items[i]);
    }

    return result;
}
fn filter[T](items []T, predicate fn(T) bool) []T {
    var result []T = (mem::new(items.len * sizeof T) as *T)[:items.len];
    var count = 0;

    loop 0..items.len : i {
        if predicate(items[i]) {
            result[count] = items[i];
            count++;
        }
    }

    return result[:count]; // Trim to actual size
}
fn reduce[T, Acc](items []T, initial Acc, combine fn(Acc, T) Acc) Acc {
    var accumulator = initial;

    loop 0..items.len : i {
        accumulator = combine(accumulator, items[i]);
    }

    return accumulator;
}
fn find[T](items []T, predicate fn(T) bool) ?T {
    loop 0..items.len : i {
        if predicate(items[i]) {
            return some items[i];
        }
    }
    return none;
}
fn any[T](items []T, predicate fn(T) bool) bool {
    loop 0..items.len : i {
        if predicate(items[i]) {
            return true;
        }
    }
    return false;
}
fn all[T](items []T, predicate fn(T) bool) bool {
    loop 0..items.len : i {
        if !predicate(items[i]) {
            return false;
        }
    }
    return true;
}
fn zip[T, U](items1 []T, items2 []U) [](T, U) {
    var min_len = items1.len;
    if items2.len < min_len {
        min_len = items2.len;
    }

    var result [](T, U) = (mem::new(min_len * sizeof (T, U)) as *(T, U))[:min_len];

    loop 0..min_len : i {
        result[i] = (items1[i], items2[i]);
    }

    return result;
}
