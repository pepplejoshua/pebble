extern {
  fn alloca(sz usize) *void;
  fn memcpy(dst *void, src *void, sz usize) void;
}

fn new(size usize) *void {
    let allocator = context.default_allocator;
    return allocator.alloc(allocator.ptr, size);
}

fn new_typed[T]() *T {
  return new(sizeof T);
}

fn new_slice[T](count usize) []T {
  let allocator = context.default_allocator;
  let ptr *T = allocator.alloc(allocator.ptr, count * (sizeof T));
  return ptr[:count];
}

fn delete_slice[T](slice *[]T) void {
  delete(slice.data);
  slice.data = nil;
}

fn stack_new(size usize) *void {
  return alloca(size);
}

fn realloc(data *void, size usize) *void {
    let allocator = context.default_allocator;
    return allocator.realloc(allocator.ptr, data, size);
}

fn delete(ptr *void) void {
    let allocator = context.default_allocator;
    allocator.free(allocator.ptr, ptr);
}

fn copy(dst *void, src *void, sz usize) void {
    memcpy(dst, src, sz);
}

fn align_up(value, alignment usize) usize {
  return (value + alignment - 1) & ~(alignment - 1);
}
